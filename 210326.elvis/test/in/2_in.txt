#include <string><br>#include <map><br>#include <iostream><br>#include <fstream><br>#include <filesystem><br>#include <thread><br>#include <future><br>#include <algorithm><br>#include "elvis.hpp"<br>using namespace std;<br><br>// -----Parser-----------------------------------------------------------<br>void Parser::add_text(const std::string& text)<br>{<br>    this->text = text;<br>}<br><br>void Parser::add_sep(const std::string& sep)<br>{<br>    separators.push_back(sep);<br>}<br><br>vector<string> Parser::parse()<br>{<br>    map<size_t, string> sep_pos_dict;<br>    vector<string> res;<br><br>    // this is needed to always remove longs separators first and short substring of long in the second turn<br>    sort(separators.begin(), separators.end(), [](const string& l, const string& r){ return l.length() < r.length(); });<br>    <br>    for (const string& sep : separators)<br>    {<br>        size_t pos = 0;<br>        while ((pos = text.find(sep, pos)) != string::npos)<br>        {<br>            sep_pos_dict[pos] = sep;<br>            pos += sep.length();<br>        }<br>    }<br><br>    size_t cur = 0;<br>    size_t len = text.length();<br>    auto ps = sep_pos_dict.begin();<br>    while (cur < len)<br>    {<br>        if (ps == sep_pos_dict.end())<br>        {<br>            res.push_back(text.substr(cur));<br>            cerr << "'" << res.back() << "'" << endl;       // TODO make this BOOST_LOG<br>            cur = len;<br>        }<br>        else if (ps->first < cur)<br>            ++ps;<br>        else<br>        {<br>            size_t sep_pos = ps->first;<br>            string sep = ps->second;<br><br>            if (sep_pos > cur)<br>            {<br>                res.push_back(text.substr(cur, sep_pos - cur));<br>                cerr << "'" << res.back() << "'" << endl;<br>            }<br>            cur = sep_pos + sep.length();<br><br>            ++ps;<br>        }<br>    }<br>    <br>    return res;<br>}<br>// -----Parser-----------------------------------------------------------<br><br>mutex mtx;<br><br>void check_args(int argc, const char*[])<br>{<br>    if (argc != 2)<br>        throw invalid_argument(ERR_WRONG_ARGUMENTS_NUM);<br>}<br><br>vector<string> process_file(const string& fpath)<br>{<br>    {<br>        lock_guard<mutex> lg(mtx);<br>        cerr << "thread " << this_thread::get_id() << " started" << endl;<br>    }<br><br>    ifstream in_f(fpath);       // TODO<br>    if (!in_f)<br>    {<br>        lock_guard<mutex> lg(mtx);<br>        cerr << "ERROR: can't open file for reading: " << fpath << endl;<br>        return {};<br>    }<br><br>    Parser parser;<br><br>    string line;<br>    getline(in_f, line);<br>    cerr << "line: " << line << endl;<br>    parser.add_text(line);<br><br>    getline(in_f, line);<br>    while (in_f)<br>    {<br>        cerr << "sep: '" << line << "'" << endl;<br>        parser.add_sep(line);<br>        getline(in_f, line);<br>    }<br><br>    vector<string> res = parser.parse();<br>    {<br>        lock_guard<mutex> lg(mtx);<br>        cerr << "thread " << this_thread::get_id() << " finished" << endl;<br><br>        // cout << "[" << de.path().filename() << "]:" << endl;     // TODO<br>        // for (const string& str : res)<br>        //     cout << str << endl;<br>    }<br>    return res;<br>}<br><br>void parallel_process(const string& dir_path)<br>{<br>    filesystem::path in_folder(dir_path);<br>    if (!filesystem::exists(in_folder))<br>        throw invalid_argument(ERR_PATH_NOT_EXIST);<br>    if (!filesystem::is_directory(in_folder))<br>        throw invalid_argument(ERR_PATH_NOT_DIR);<br><br>    unsigned thr_num = thread::hardware_concurrency();<br>    vector<future<vector<string>>> tasks(thr_num);<br>    mutex mtx;<br>    // TODO | maybe we can just create as many tasks as we wish and they will be executed in cores number batches<br><br>    auto file_iter = filesystem::directory_iterator(in_folder);<br>    auto file_iter_end = end(filesystem::directory_iterator(in_folder));<br><br>    bool started = false;<br>    int running = 0;<br>    while (!started || running > 0)<br>    {<br>        for (unsigned i = 0; i < thr_num; ++i)<br>            if (!tasks[i].valid())<br>            {<br>                if (file_iter != file_iter_end)<br>                {<br>                    tasks[i] = async(launch::async, process_file, file_iter->path().string());<br>                    ++file_iter;<br>                    ++running;<br>                    started = true;<br>                }<br>            }<br>            else if (tasks[i].wait_for(0ms) == future_status::ready)<br>            {<br>                if (file_iter != file_iter_end)<br>                {<br>                    tasks[i] = async(launch::async, &process_file, file_iter->path().string());<br>                    ++file_iter;<br>                }<br>                else<br>                {<br>                    tasks[i] = {};<br>                    --running;<br>                }<br>            }<br>        this_thread::sleep_for(100ms);<br>    }<br><br>    cout << "running == " << running << endl;<br>}<br>
<br>
 
::
<
>
,
(
)
;